/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_example_mayohn_nokillprocess_Watcher.h"
#include <android/log.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/resource.h>
#include<sys/stat.h>

#define LOG_TAG    "test===="
#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG,__VA_ARGS__)
#define LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)

//java类Watcher对象
jobject m_object;
jmethodID m_mid;
using namespace std;
long addProcess();
int start(int argc, char* srvname, char* sd);
/* Header for class com_example_mayohn_nokillprocess_Watcher */

/*
 * Class:     com_example_mayohn_nokillprocess_Watcher
 * Method:    createWatcher
 * Signature: (Ljava/lang/String;)Z
 */
JNIEXPORT jboolean JNICALL Java_com_example_mayohn_nokillprocess_Watcher_createWatcher
  (JNIEnv *env, jobject obj, jstring str){
        /*jclass clazz=(*env).GetObjectClass(obj);//获取watcher类
        m_object=(*env).NewGlobalRef(obj);//创建本地类对象
        m_mid=(*env).GetMethodID(clazz,"isServiceRunning","()I");//获取Java方法ID
        (*env).CallIntMethod(m_object,m_mid);*/
        //addProcess();
       start(1,"test","sdcard");
  return false;
  }

/*
 * Class:     com_example_mayohn_nokillprocess_Watcher
 * Method:    connectToMonitor
 * Signature: ()Z
 */
JNIEXPORT jboolean JNICALL Java_com_example_mayohn_nokillprocess_Watcher_connectToMonitor
  (JNIEnv *env, jobject obj){
  return true;
  }

/*
 * Class:     com_example_mayohn_nokillprocess_Watcher
 * Method:    sendMsgToMonitor
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_example_mayohn_nokillprocess_Watcher_sendMsgToMonitor
  (JNIEnv *env, jobject obj, jstring str){
  return 123;
  }
/**
 * srvname  进程名
 * sd 之前创建子进程的pid写入的文件路径
 */
int start(int argc, char* srvname, char* sd) {
    pthread_t id;
    int ret;
    struct rlimit r;
    int pid = fork();
    if (pid < 0) {
        LOGI("first fork() error pid %d,so exit", pid);
        exit(0);
    } else if (pid != 0) {
        LOGI("first fork(): I'am father pid=%d,%d", getpid(),getppid());
        //exit(0);
    } else { //  第一个子进程
        LOGI("first fork(): I'am child pid=%d,%d", getpid(),getppid());
        setsid();//当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离
        LOGI("first fork(): setsid=%d", setsid());
        umask(0); //为文件赋予更多的权限，因为继承来的文件可能某些权限被屏蔽
        int pid = fork();
        if (pid == 0) { // 第二个子进程
            while(true){
                LOGI("first fork(): I'am child2 pid=%d,%d", getpid(),getppid());
            }

           /* FILE  *fp;
            sprintf(sd,"%s/pid",sd);
            if((fp=fopen(sd,"a"))==NULL) {//打开文件 没有就创建
                LOGI("%s文件还未创建!",sd);
                ftruncate(fp, 0);
                lseek(fp, 0, SEEK_SET);
            }
            fclose(fp);
            fp=fopen(sd,"rw");
            if(fp>0){
                char buff1[6];
                int p = 0;
                memset(buff1,0,sizeof(buff1));
                fseek(fp,0,SEEK_SET);
                fgets(buff1,6,fp);  //读取一行（pid）
                LOGI("读取的进程号：%s",buff1);
                if(strlen(buff1)>1){ // 有值
                    kill(atoi(buff1), SIGTERM); // 把上一次的进程干掉，防止重复执行
                    LOGI("杀死进程，pid=%d",atoi(buff1));
                }
            }
            fclose(fp);
            fp=fopen(sd,"w");
            char buff[100];
            int k = 3;
            if(fp>0){
                sprintf(buff,"%lu",getpid());
                fprintf(fp,"%s\n",buff); // 把进程号写入文件
            }
            fclose(fp);
            fflush(fp);

            LOGI("I'am child-child pid=%d", getpid());
            chdir("/"); //<span style="font-family: Arial, Helvetica, sans-serif;">修改进程工作目录为根目录，chdir(“/”)</span>
            //关闭不需要的从父进程继承过来的文件描述符。
            if (r.rlim_max == RLIM_INFINITY) {
                r.rlim_max = 1024;
            }
            int i;
            for (i = 0; i < r.rlim_max; i++) {
                close(i);
            }

            umask(0);
            ret = pthread_create(&id, NULL, (void *) thread, srvname); // 开启线程，轮询去监听启动服务
            if (ret != 0) {
                printf("Create pthread error!\n");
                exit(1);
            }
            int stdfd = open ("/dev/null", O_RDWR);
            dup2(stdfd, STDOUT_FILENO);
            dup2(stdfd, STDERR_FILENO);*/
        } else {
            exit(0);
        }
    }
    return 0;
}

/**
 * 启动Service
 */
/*void Java_com_yyh_fork_NativeRuntime_startService(JNIEnv* env, jobject thiz,
        jstring cchrptr_ProcessName, jstring sdpath) {
    char * rtn = jstringTostring(env, cchrptr_ProcessName); // 得到进程名称
    char * sd = jstringTostring(env, sdpath);
    LOGI("Java_com_yyh_fork_NativeRuntime_startService run....ProcessName:%s", rtn);
    a = rtn;
    start(1, rtn, sd);
}*/
/**
 * 执行命令
 */
/*void ExecuteCommandWithPopen(char* command, char* out_result,
        int resultBufferSize) {
    FILE * fp;
    out_result[resultBufferSize - 1] = '\0';
    fp = popen(command, "r");
    if (fp) {
        fgets(out_result, resultBufferSize - 1, fp);
        out_result[resultBufferSize - 1] = '\0';
        pclose(fp);
    } else {
        LOGI("popen null,so exit");
        exit(0);
    }
}*/
 /**
   * 检测服务，如果不存在服务则启动.
   * 通过am命令启动一个laucher服务,由laucher服务负责进行主服务的检测,laucher服务在检测后自动退出
   */
  /*void check_and_restart_service(char* service) {
      LOGI("当前所在的进程pid=",getpid());
      char cmdline[200];
      sprintf(cmdline, "am startservice --user 0 -n %s", service);
      char tmp[200];
      sprintf(tmp, "cmd=%s", cmdline);
      ExecuteCommandWithPopen(cmdline, tmp, 200);
  }*/
long addProcess()
{
    pid_t fpid; //fpid表示fork函数返回的值
    int count=0;
    fpid=fork();
    if (fpid < 0){
       LOGI("error in fork!");
    }else if (fpid == 0) {

       int index=0;
       while(true){

         if(getppid()==1){//主进程退出来了
             //char* cmd="am start -n com.example.mayohn.nokillprocess/.MainActivity";
              LOGI("i am the child process, my process id is %d，%d",getpid(),getppid());
              char* cmd="am start -n com.android.calendar/com.android.calendar.LaunchActivity";

         }

       }
    }else {
       LOGI("i am the parent process, my process id is %d，%d",getpid(),getppid);
       exit(0);
    }
    return 0;
}